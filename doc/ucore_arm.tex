%        File: ucore_arm.tex
%     Created: Fri Apr 06 12:00 PM 2012 C
% Last Change: Fri Apr 06 12:00 PM 2012 C
%
\documentclass[a4paper]{article}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{algorithm}
\usepackage{xcolor}
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{ %
  basicstyle=\footnotesize,           % the size of the fonts that are used for the code
  numbers=none,                   % where to put the line-numbers
  numberstyle=\footnotesize,          % the size of the fonts that are used for the line-numbers
  stepnumber=2,                   % the step between two line-numbers. If it's 1, each line
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=none,                   % adds a frame around the code
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                   % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
  numberstyle=\tiny\color{gray},        % line number style
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{mauve},         % string literal style
  escapeinside={\%*}{*)},            % if you want to add a comment within your code
  morekeywords={*,...}               % if you want to add more keywords to the set
}


\begin{document}
\title{UCORE Porting on ARM9}
\author{Chen Yuheng \\ Yang Yang}
\maketitle

\section{Introduction}
This report gives a brief introduction to our OS cource project -- 
\emph{UCORE} porting onto ARM9 platform, including the kernel, limited
device drivers as well as the user-lib. \emph{UCORE} is an experimental 
modern operating system that includes a basic memory manager, a limited process/
thread scheduler, linux-like VFS and incomplete POSIX-compatible syscall 
interface. Thanks to Mao Junjie
\footnote{https://github.com/chyh1990/ucore-arch-arm} and Yu Kuanlong
\footnote{http://gitorious.org/ucorearm}, we are enabled to finish our
 work as fast as possible. Currently, the following platforms are supported:
 \begin{itemize}
   \item \emph{Versatilepb}, which is simulated with qemu-arm-system.
     The hardware configuration is available in qemu's source code,
     several important components of which is summarized in
     Table. \ref{tab:versatile1}.
     \begin{table}[h]
       \centering
       \begin{tabular}{|r|rrr|}
         \hline
         Component & Type & Base Address &  IRQ \\
         \hline
         Core     &  ARM9EJ-S & -- & -- \\
         Interrupt Controller & P1190 & 0x10140000 & IRQ/FIQ \\
         Timer    &  SP804    & 0x101e2000 & 4 \\
         UART     &  PL011  & 0x101f1000 & 12  \\
         \hline
       \end{tabular}
       \caption{Versatilepb Hardware Configuration}
       \label{tab:versatile1}
     \end{table}

   \item \emph{Atmel AT91SAM} hardware platform.
 \end{itemize}

Our code is available on Google Code
\footnote{http://code.google.com/p/ucore-arch-arm/} with no warranty and
is kept updating. Any bug reports are welcomed.

\section{Source Code Organization}
This section introduces the source code orginazation of ucore-arch-arm 
and explains several Makefile tricks.
\subsection{Source Tree}
Since our work is based on ucore-x64-smp project, our code is mainly placed
in \emph{src/kern-ucore/arch/arm}, with a small amount of ARM-specific 
code mixed in the originally machine-independent code. Important directories are listed in Table. \ref{tab:dir}.

\begin{table}[h]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    Directory & Description \\
    \hline
    debug  &     debug console after a kernel panic \\
    driver &     device driver interface definition \\
    include &    useful macros for ARM9              \\
    init   &     kernel entry point and initialization code \\
    libs   &     utilities for eabi compiler and optimized memcpy/memset \\
    mach-xxx &   machine-dependent code, driver implementation \\
    mm     &     low-level memory management \\
    process   &  context switch             \\
    sync   &     atomic operation           \\
    syscall &     ARM-specific syscall machanism \\
    trap   &     exception handling  \\
    \hline
  \end{tabular}
  \caption{ucore-arch-arm directories}
  \label{tab:dir}
\end{table}

\subsection{Makefile}
UCore does not have a configuration system yet, thus hardware specific
definition is defined in a Makefille called \emph{config-arm.mk} and
more detailed configuration is defined in \emph{board.h} in the 
corresponding machine directory.
\begin{enumerate}
  \item Options in \emph{config-arm.mk}:
    \begin{table}[h]
      \centering
      \begin{tabular}{|l|l|}
        \hline
        Item & Description \\
        \hline
        ARCH\_ARM\_CPU  & CPU Type \\
        ARCH\_ARM\_BOOTLOADER\_BASE & Physical address of bootloader(not used in simulation) \\
        ARCH\_ARM\_BOARD & board type, corresponding to mach-xxx \\
        ARCH\_ARM\_KERNEL\_BASE & Linking address of kernel \\
        PLATFORM\_DEF  &  predefined C macros \\
        \hline
        TARGET\_CC\_SYSTEM\_LIB & system library of cross-compiler \\
        TARGET\_CC\_PREFIX & cross-compiler prefix \\
        \hline
      \end{tabular}
      \caption{config-arm.hk}
      \label{tab:configarm.mk}
    \end{table}

  \item Options in \emph{board.h}
    \begin{table}[h]
      \centering
      \begin{tabular}{|l|l|}
        \hline
        Item & Description \\
        \hline
        SDRAM0\_START & Physical base address of RAM \\
        SDRAM0\_SIZE  & RAM size \\
        IO\_SPACE\_START & Physical address of memory-map IO \\
        IO\_SPACE\_SIZE  & Size of memory-map IO space \\
        HAS\_RAMDISK     & use ramdisk if defined \\
        HAS\_NANDFLASH   & use nandflash driver if defined \\
        \hline
      \end{tabular}
      \caption{board.h}
      \label{tab:board.h}
    \end{table}
\end{enumerate}

More detailed memory layout is defined in memlayout.h in the corresponding
machine directory, see Section. \ref{sec:mm}.

\section{Implementation Details}
\subsection{Booting}
Bootstrap diverses on different platforms: on hardware platforms, a ELF
loader is needed, while on the simulator, qemu-system-arm, no bootloader
is needed, since qemu can load a ELF kernel automatically.
A bootable kernel image  comprises  the following parts\footnote{see mk/arch-arm.mk}:

\begin{table}[h]
  \centering
  \begin{tabular}{|r|r|}
    \hline
    File Offset & Binary \\
    \hline
    0x0000      & bootloader \\
    0x1000      & kernel+ramdisk     \\
    \hline
  \end{tabular}
  \caption{Bootable Kernel Image Layout}
  \label{tab:layout}
\end{table}
For convenience, root filesystem image(ramdisk) is linked
with the kernel, appending at the end of it
\footnote{see arch/arm/Makefile}.


\subsection{Exception Handling}
ARM CPU has 8 running modes, ucore only use 5 of them: Software Interrupt (SWI), Prefetch Abort(PABT), 
Data Abort (DABT), Hardware Interrupt (IRQ) and User Mode.
\begin{itemize}
  \item SWI: user mode to supervisor mode transition,
    ucore use it to implement system call mechanism.
  \item PABT/DABT: used by virtual memory manager.
  \item IRQ: handling hardware interrupt, e.g. timer,
    UART and other devices.
  \item USR: running user applications.
\end{itemize}
For each running mode except user mode, ARM core automatically switches kernel stack in mode transition, which means all these stacks should be set properly before entering ucore kernel.

The kernel use a trapframe structure to save registers when privilege mode transition occurs:
\begin{algorithm}[h]
   \begin{lstlisting}[language={C++}]
/* General purpose registers minus fp, sp and pc */
struct pushregs {
    uint32_t reg_r [13];
};

struct trapframe {
	uint32_t tf_sr;			// saved status register
	uint32_t tf_trapno;		// Trap number
	uint32_t tf_err;		// Error code
	struct pushregs tf_regs;
	uint32_t tf_esp;		// esp
	uint32_t tf_epc;		// eip, actually lr
} __attribute__((packed));

\end{lstlisting}
\caption{Trapframe}
\end{algorithm}

The trapframe is constructed by the assembly in trap/trapentry.S, be aware with the fact that
ARM core will switch fp, sp, ip automatically.

\subsection{Memory Management}
\label{sec:mm}
The MMU of ARM9 is very different from X86's, leading to some hacks in src/mm/pmm.c,
which should be architecture-independent. These changes are marked with a macro
\emph{ARCH\_ARM}, defined in config-arm.mk.


\subsection{Context Switch and System Call}
The syscall mechanism is borrowed from Linux2.6. In ARM, a special 
instruction \emph{swi} handles user mode to supervisor mode transition.

In ucore, we employ the following system calling convention:
\begin{enumerate}
  \item \emph{r0 - r3}, arguments(from left to right)
  \item \emph{swi [syscall nr]}
  \item return value in \emph{r0}
\end{enumerate}

Syscall is wrapped in user mode library and can be called as a normal 
C function. This wrapper is generated automatically by 
\emph{misc/arm\_gensyscall.py}.

\subsection{Developer Caveat}
More efforts needed to improve the usability and stability of ucore-arch-arm. Here is a TODO list:
\begin{itemize}
  \item High memory kernel. MMU must be enabled as soon as possible.
  \item Multiply ARM-architecture support. Our work currently supports
    ARMv5 architecture, but it should be easy to support ARMv4 and ARMv7
    with minor modifications.
  \item Swapping is disabled currently.
  \item Performance issues, e.g., D-cache management.
\end{itemize}

The most privileged one might be moving the kernel to high memory space, so that all ARM platforms
can share identical (or nearly identical) memory layout. But currently you might need to change
the kernel memory layout (in memlayout.h) and the user mode application's linker script 
according to your platform.

\section{Demonstration}

\section{Conclusion}



\end{document}


